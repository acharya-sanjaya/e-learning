import {ChapterType, NoteType} from "./01";

const chapterOne: ChapterType = {
  topic: "Programming with 8085 and 8086 Microprocessors",
  contents: [
    {
      topic: "8085 Microprocessor",
      description: [
        "Data Bus: 8-bit",
        "Address Bus: 16-bit",
        "Operation Modes: Fetch, Decode, Execute",
        "Memory: 64KB addressable, includes RAM, ROM and I/O Ports",
        "Power: +5V",
        "Clock: ~3MHz",
        "",
        "Instructions (74):",
        "-> Data Transfer: MOV, MVI, IN, OUT",
        "-> Arithmetic: ADD, SUB, INR, DCR",
        "-> Logical: ANA, ORA, CMA, RLC",
        "-> Control: NOP, HLT, DI, EI",
        "-> Branching: JMP, CALL, RET, JZ, JNZ",
        "-> Instruction can be 1-byte, 2-byte, or 3-byte",
        "",
        "Instruction Format:",
        "-> 1-byte: Opcode(8)",
        "-> 2-byte: Opcode(8), Operand(8)",
        "-> 3-byte: Opcode(8), Operand_1(8), Operand_2(8)",
        "",
        "Data Format:",
        "-> Byte: 8-bit",
        "-> Word: 16-bit",
        "-> Supports BCD arithmetic",
        "-> Does not support strings and floating point",
        "",
        "Registers:",
        "-> Accumulator: A (Code: 111)",
        "-> General Purpose: B, C, D, E, H, L (Code: 000 - 101)",
        "-> Program Counter: PC",
        "-> Stack Pointer: SP",
        "",
        "Flag Registers (5):",
        "-> Zero(Z): Z=1 => Result is 0",
        "-> Sign(S): S=1 => Result is negative",
        "-> Parity(P): P=1 => Odd parity",
        "-> Auxiliary Carry(AC): Carry in BCD arithmetic",
        "-> Carry(C): Carry in binary arithmetic",
        "",
        "Hardware Interrupts (5):",
        "-> TRAP: Non-maskable, highest priority, critical situations (eg, power failure)",
        "-> RST 75, RST 65, RST 55: Maskable interrupts with descending priority",
        "-> INTR: General-purpose interrupt, vectored through INTA signal",
        "-> Maskable Interrupts means these can be masked (disabled or ignored)",
        "",
        "Addressing Modes (5):",
        "-> Immediate",
        "-> Direct",
        "-> Indirect",
        "-> Register",
        "-> Implied / Implicit (no operand)",
      ],
    },
    {
      topic: "INTENDED_GAP",
      description: [],
    },
    {
      topic: "8086 Microprocessor",
      description: [
        "Data Bus: 16-bit",
        "Address Bus: 20-bit",
        "Operation Modes: Fetch, Decode, Execute (Supports pipelining)",
        "Instruction Pipelining: Overlapping execution phases (Fetching next instruction while executing current one)",
        "Memory: 1MB, includes RAM, ROM, and I/O Ports",
        "Power: +5V",
        "Clock: 5 to 10 MHz",
        "",
        "Instructions:",
        "-> Data Transfer: MOV, PUSH, POP",
        "-> Arithmetic: ADD, SUB, INC, DEC, MUL, DIV",
        "-> Logical: AND, OR, XOR, NOT, TEST",
        "-> Control: NOP, HLT, JMP, CALL, RET",
        "-> String: MOVSB, MOVSW, CMPSB, SCASB, REP",
        "-> Comparison: CMP, TEST, JZ, JNZ, JC, JNC",
        "-> Instruction sizes: 1-byte, 2-byte, or 3-byte",
        "",
        "Instruction Format:",
        "-> 1-byte: Opcode(8)",
        "-> 2-byte: Opcode(8), Operand(8)",
        "-> 3-byte: Opcode(8), Operand_1(8), Operand_2(8)",
        "-> For string operations, implicit mode is used",
        "",
        "Data Format:",
        "-> Byte: 8-bit",
        "-> Word: 16-bit",
        "-> Does not directly support BCD operations (but possible via software)",
        "-> Does not supports floating-point operations",
        "",
        "Registers:",
        "-> Accumulator: AX (Code: 000)",
        "-> Base Register: BX (Code: 011)",
        "-> Count Register: CX (Code: 010)",
        "-> Data Register: DX (Code: 100)",
        "-> Stack Pointer: SP",
        "-> Base Pointer: BP",
        "-> Source Index: SI",
        "-> Destination Index: DI",
        "-> Segment Registers: CS, DS, SS, ES",
        "-> Instruction Pointer: IP",
        "",
        "Pointers and Index Registers:",
        "-> SI: Source Index, used as source pointer for string operations",
        "-> DI: Destination Index, used as destination pointer for string operations",
        "-> BP: Base Pointer, points to base of stack segment",
        "-> SP: Stack Pointer, points to top of stack",
        "",
        "Flag Registers (size=16 bits, total flags=9):",
        "-> Carry (C)",
        "-> Parity (P)",
        "-> Auxiliary Carry (AC)",
        "-> Zero (Z)",
        "-> Sign (S)",
        "-> Trap (T): Enables single-step execution",
        "-> Interrupt Enable (I): I=1 => Enabled",
        "-> Direction (D): D=1 => String operations move in reverse",
        "-> Overflow (O): O=1 => Overflow in arithmetic operation",
        "",
        "Segmentation:",
        "-> CS: Code Segment",
        "-> DS: Data Segment",
        "-> SS: Stack Segment",
        "-> ES: Extra Segment",
        "",
        "Segment: Offset Addressing",
        "-> Physical address = Segment * 10H + Offset address",
        "-> Eg; Let CS= 2000H, IP = 0100H",
        "-> Then, Physical address = 2000H * 10H + 100H = 20100H",
        "",
        "Interrupts:",
        "-> Supports both h/w and s/w interrupts",
        "-> 256 interrupts (0-255): uses IVT",
        "",
        "Addressing Modes (usually 11 might differ according to book):",
        "-> Immediate",
        "-> Direct / Displacement",
        "-> Indirect",
        "-> Register",
        "-> Indexed",
        "-> Based Indexed",
        "-> Register Indirect",
        "-> Indexed Indirect",
        "-> Based Indexed Indirect",
        "-> String (Implied mode)",
        "-> I/O",
      ],
    },
    {
      topic: "INTENDED_GAP",
      description: [],
    },
    {
      topic: "Assembly Language Programming",
      description: [
        "Low-level, direct access to h/w components so, not easily portable",
        "",
        "Structure of an Assembly Program:",
        "-> Labels: identifier for memory address, helps in jumps and loops",
        "-> Mnemonics: represents instruction making it (more readable)",
        "-> Operands: like variables",
        "-> Directives: give instructions to the assembler",
        "-> Comments: for readability",
        "",
        "Debugging Assembly Programs:",
        "-> Stepping through instructions: execute one instruction at a time and check",
        "-> Use of breakpoints: they pause program execution at a specific line",
        "-> Inspect registers and memory: monitor values repeatedly to detect unexpected updates",
        "",
        "Optimizing Assembly Programs:",
        "-> Minimize instruction set",
        "-> Utilize registers",
        "-> Loop unrolling (expand loops before running to make normal flow instead of iteration)",
        "-> Instruction pipelining",
        "",
      ],
    },
    {
      topic: "COM",
      description: [
        "Executable file type",
        "Simple, single segment, fast, less portable",
        "Maximum 64KB",
        "Flat binary format, no header or metadata",
        "Always loads at 0100H (fixed)",
      ],
    },
    {
      topic: "EXE",
      description: [
        "Executable file type",
        "Can be more than 64KB",
        "Contains header or metadata",
        "Support multiple segments, modularity",
        "Loading address not fixed",
      ],
    },
    {
      topic: "Assembling, Linking and Executing",
      description: [
        "Assembling: Converting assembly code to object code",
        "",
        "Linking: Combining (multiple files or libraries if any) object code into executable file includes resolving references",
        "",
        "Executing: Load, initialize, execute and terminate the linked executable file",
        "-> MASM and TASM are popular assemblers (for windows), LINK is a popular linker",
      ],
    },
    {
      topic: "Single Pass Assemblers",
      description: [
        "Translating instructions + resolving symbols in single pass",
        "Single traversal (means reads source code from top to bottom ONCE)",
        "Faster but can't handle forward references",
      ],
    },
    {
      topic: "Two Pass Assemblers",
      description: [
        "Build the Symbol Table (SYMTAB) in first pass",
        "Generate object code in second pass",
        "Slower but handles forward references effectively",
      ],
    },
  ],
};

const chapterTwo: ChapterType = {
  topic: "Microprocessor System",
  contents: [
    {
      topic: "I/O and Memory Interfaces",
      description: [
        "Interface: Paths through which CPU communicates with devices",
        "Parallel Interface: Multiple bit lines for data transfer",
        "-> Multiple data at a time, high transfer rate BUT signal degradation, complex wiring, synchronization issues",
        "Serial Interface: Single bit line for data transfer",
        "-> simple wiring but comparatively slower, only one bit transfer at a time",
        "",
      ],
    },
    {
      topic: "Programmable Peripheral Interface (PPI)",
      description: [
        "allows CPU to communicate with peripheral devices",
        "includes bi-directional as well as uni-directional ports",
        "I/O ports:",
        "-> I/O ports: allow transfer",
        "-> Control ports: manage direction of transfer (in/out)",
        "",
        "Control Register:",
        "-> Configuration register: determine modes (input/output) of each ports",
        "-> Control bits: interrupts, clocking, data transfer protocols",
        "",
        "Status Register:",
        "-> Interrupt Status (if interrupt is pending)",
        "-> Data Status (if data is ready to read/write)",
        "",
        "Key Features:",
        "-> Mode (in/out) control for each ports individually",
        "-> Interrupt Capabilities",
        "-> Data Latching: (store data temporarily in a buffer)",
        "-> Bi-directional ports",
        "",
        "Modes:",
        "-> Mode 0: Basic (no handshaking or interrupts)",
        "-> Mode 1: Strobe signal (handshaking signal) and interrupt support",
        "-> Mode 2: Bi-directional",
      ],
    },
    {
      topic: "Serial Interface",
      description: [
        "Communication: Single data line transfers data bits",
        "Synchronous:",
        "-> Share a common clock signal",
        "-> faster, less flexible",
        "-> Eg; SPI, IIC, USB",
        "Asynchronous:",
        "-> Start/stop bits signal the beginning and end of data",
        "-> slower, more flexible",
        "-> Eg; UART, RS-232 (Recommended), RS-485",
      ],
    },
    {
      topic: "Serial Interface Standards",
      description: [
        "UART: async, wires=2, 1mbps, bluetooth",
        "SPI: sync, wires=4, 10mbps, sensors and sd cards",
        "IIC: sync, wires=2, 400kbps, eeprom and rtc and sd cards",
        "USB: sync, wires=4-9, 40gbps, storage",
        "RS-232: async, wires=3, 115kbps, point-to-point, short distance",
        "RS-485: sync, wires=2, 10mbps, multi-point, long distance",
      ],
    },
    {
      topic: "Direct Memory Access (DMA)",
      description: [
        " Take control over system bus for direct data transfer between memory and peripherals",
        "Modes of DMA:",
        "-> Burst Mode: Data is transferred in blocks without CPU interruption",
        "-> Cycle Stealing: DMA takes control of bus for short periods (interleaving with CPU)",
        "-> Transparent Mode: DMA takes control of bus only when CPU is not using it",
        "-> Fly-by: Data transfer but nothing is stored in the controller's buffer (if data lost, no recovery)",
      ],
    },
  ],
};

const chapterThree: ChapterType = {
  topic: "Interrupt Operations",
  contents: [
    {
      topic: "Interrupts",
      description: [
        "Interrupt: Signal requesting CPU attention",
        "-> Maskable: Can be ignored",
        "-> Non-Maskable: Cannot be ignored",
        "-> Hardware Interrupts: Asynchronous",
        "-> Software Interrupts: Synchronous",
        "-> Vector Interrupts: ISR is present in IVT, so, fixed location for each interrupt",
        "-> Edge-Triggered Interrupts: Signal transitions (state update)",
        "-> Level-Triggered Interrupts: Signal level (triggers when high state only or low state only)",
        "-> Pulse-Triggered Interrupts: triggered by sending pulse signal for a short duration",
        "-> Polled Interrupts: Continuously check if interrupt occurs",
        "",
        "Interrupt Service Routine (ISR):",
        "-> A function that executes when the respective interrupt occurs",
        "-> Fast, non-blocking, minimal resource usage",
        "-> Structure: Entry -> Process -> Exit",
      ],
    },
    {
      topic: "Interrupt Handling",
      description: [
        "8085: 5 interrupts (TRAP, RST 75, 65, 55, INTR)",
        "8086: More complex; uses Interrupt Vector Table (256 entries)",
        "INTR in 8085 vs INT in 8086: Unified architecture in 8086 for managing up to 256 interrupts",
      ],
    },
    {
      topic: "Parallelism",
      description: [
        "Real Parallelism: Multiple processors execute simultaneously",
        "Pseudo-Parallelism: One processor switches rapidly between tasks (time slicing)",
        "Flynn's Classification: ",
        "-> SISD (Single Instruction Single Data)",
        "-> SIMD (Single Instruction Multiple Data)",
        "-> MIMD",
        "-> MISD",
      ],
    },
    {
      topic: "Levels of parallelism",
      description: [
        "Instruction Level Parallelism (ILP):",
        "-> Achieved using pipeline architecture and super-scalar processors",
        "-> Limitations: Data dependencies, branching hazards",
        "",
        "Thread Level Parallelism (TLP):",
        "-> Achieved using multithreading and hyper-threading techniques",
        "-> Suitable for small concurrent tasks",
        "-> Shared memory for communication",
        "-> Limitations: Requires synchronization mechanisms",
        "",
        "Process Level Parallelism (PLP):",
        "-> Achieved using multi-core processors, distributed computing, or clusters",
        "-> Involves context switching and Inter process (IPC)",
        "-> Used in running multiple applications simultaneously",
      ],
    },
    {
      topic: "Resource Allocation and Deadlock",
      description: [
        "Resource Allocation: OS assigns resources to processes for execution",
        "Deadlock: Circular waiting on resources among multiple processes",
        "Causes of Deadlock:",
        "-> Mutual Exclusion",
        "-> Hold and Wait",
        "-> No Preemption",
        "-> Circular Wait",
        "",
        "Deadlock Handling: Prevention, Avoidance (eg, Banker's Algorithm), or Detection & Recovery",
        "Use Semaphores, Monitors to prevent deadlocks",
      ],
    },
    {
      topic: "Inter Process Communication",
      description: [
        "Shared Memory",
        "Message Passing: Processes send data blocks to message queues or pipes",
        "Signals: lightweight message to notify about events",
        "Sockets: send data across different machines over internet",
        "Pipes: send data between processes",
        "Remote Procedure Calls (RPC): one process invoke function on another process",
      ],
    },
  ],
};

const chapterFour: ChapterType = {
  topic: "Control and Central Processing Unit",
  contents: [
    {
      topic: "Control Memory",
      description: [
        "Stores microinstructions for CPU operations",
        "Implemented with ROM, PROM or even RAM",
        "",
        "Types of Control Memory:",
        "-> Horizontal (parallel / multiple): Each bit maps to specified control signal, complex",
        "-> Vertical (encoded): use fewer bits (narrow), requires decoding, memory efficient, low flexibility",
      ],
    },
    {
      topic: "Addressing Sequencing",
      description: [
        "Defines the order in which CPU will access instructions and data from memory",
        "Defines the flow of control through microinstructions",
        "Methods: Sequential (linear), Conditional branching (if-else / goto), Subroutine calling (go to subroutine and return)",
      ],
    },
    {
      topic: "Computer Configuration",
      description: [
        "Hardware components: CPU, memory, I/O",
        "Bus: Medium for communication between components",
        "Motherboard (main circuit board): Connects components and provides electrical power to them",
        "Von Neumann Architecture:",
        "-> CPU and memory are separate so need to load data from via BUS",
        "-> Single memory space for instructions and data",
        "-> Von Neumann bottleneck: CPU processing speed is high but memory access is slow, so CPU has to wait",
        "",
        "Harvard Architecture:",
        "-> Separate BUS to load data and instructions, so parallel access",
        "-> Complex, expensive",
        "",
        "Modern Architecture: Combines both",
      ],
    },
    {
      topic: "Microinstruction Format",
      description: ["Types: Horizontal (parallel signals) and Vertical (encoded signals)"],
    },
    {
      topic: "Design of Control Unit",
      description: [
        "Hardwired Control:",
        "-> Fixed circuit",
        "-> Use finite state machine with combinational and sequential logic",
        "-> Complex, less flexible but faster",
        "",
        "Microprogrammed Control:",
        "-> Uses control memory to store microinstructions",
        "-> Microinstructions contain control signals as well as address of next microinstruction",
        "-> Simple, flexible, reusable but slower and large memory",
      ],
    },
    {
      topic: "Cache Memory",
      description: [
        "Levels of Cache Memory:",
        "-> L1 cache, L2 cache, L3 cache",
        "-> Speed: L1 > L2 > L3",
        "-> size: L1 < L2 < L3",
        "-> L1: Located in CPU chip (not shared)",
        "-> L2: Can be located in CPU chip or separate chip near CPU (can be shared)",
        "-> L3: Shared by multiple CPU cores",
        "",
        "Cache Organization:",
        "-> Direct Mapped: Each memory block maps to 1 specific cache line",
        "-> Fully Associative: Any memory block can be mapped to any cache line",
        "-> Set Associative: Each memory block maps to a 'SET' of cache lines (combination of direct mapped and fully associative)",
        "-> write-back: write on cache first, write to main memory only when cache is evicted (with the help of dirty bits to find if data is modified)",
        "-> write-through: write on cache and main memory simultaneously (slower but maintains consistency)",
      ],
    },
    {
      topic: "RISC vs CISC",
      description: [
        "Reduced RISC:",
        "-> Small and Simplified instructions",
        "-> Single-cycle execution",
        "-> Load/store design",
        "-> Large set of registers",
        "-> Pipelining-friendly",
        "-> Few Addressing Modes",
        "-> High performance, lower power consumption",
        "-> Large code size and relies heavily on compilers",
        "-> Eg; MIPS, ARM, PowerPC",
        "",
        "CISC:",
        "-> Complex instructions",
        "-> Multi-cycle execution",
        "-> Variable-length instructions",
        "-> Supports direct memory access",
        "-> Micro-coded control units",
        "-> Ease of programming but slower",
        "-> Eg; x86, VAX",
      ],
    },
    {
      topic: "Pipelining and Parallel Processing",
      description: [
        "Pipelining: Overlaps instruction execution; stages include Fetch, Decode, Execute, Write-Back (write result into memory)",
        "Parallel Processing: Multiple instructions executed concurrently using multiple ALUs or CPUs",
        "Super-scalar: Multiple pipelines in a single CPU",
      ],
    },
  ],
};

const chapterFive: ChapterType = {
  topic: "Computer arithmetic and memory system",
  contents: [
    {
      topic: "Complement of a number",
      description: [
        "One's Complement: Convert number into binary form, then invert all bits (0 -> 1, 1-> 0)",
        "Two's Complement: One's complement + 1",
      ],
    },
    {
      topic: "Memory Interleaving",
      description: [
        "Distribute memory address across multiple memory modules",
        "Key features:",
        "-> Parallelism: Different memory modules can be accessed simultaneously",
        "",
        "Types:",
        "-> Bit Interleaving: Distribute bits across multiple memory modules",
        "-> Block Interleaving: Divides memory into blocks and assigns each block to a different modules",
      ],
    },
    {
      topic: "Cache Memory Principles",
      description: [
        "Locality of Reference:",
        "-> Temporal Locality: Recently accessed data is likely to accessed again soon",
        "-> Spatial Locality: Data near the recently accessed data is likely to accessed again soon",
        "",
        "Speeds up data access for frequently/recently used data",
        "Faster than RAM but smaller",
      ],
    },
  ],
};

const chapterSix: ChapterType = {
  topic: "Input-Output organization and multiprocessor",
  contents: [
    {
      topic: "Peripheral Devices and I/O Modules",
      description: [
        "Peripheral Devices: Input (keyboard, mouse), Output (monitor, printer), Storage (disks)",
        "I/O Modules: Interface between peripherals and CPU/memory (how peripherals are accessed)",
        "Functions: Control, Addressing, Data transfer, Synchronization",
      ],
    },
    {
      topic: "Input-Output Interface",
      description: [
        "Programmed I/O: CPU handles all data transfers",
        "Interrupt-driven I/O: Peripherals interrupt CPU when ready for data",
        "Direct Memory Access (DMA): Data transferred between memory and device without CPU intervention",
      ],
    },
    {
      topic: "Modes of Data Transfer",
      description: [
        "Synchronous: Data transfer at fixed intervals; requires clock signal",
        "Asynchronous: Data transfer without a clock; uses handshaking signals",
        "DMA: Direct memory access, bypassing CPU for large data transfers",
      ],
    },
    {
      topic: "Interconnection Structures",
      description: [
        "Bus-based: CPUs and memory communicate via a shared bus",
        "Crossbar: Each CPU connects to every memory module",
        "Mesh/Hypercube: CPUs connected in multi-dimensional arrays",
      ],
    },
    {
      topic: "Inter-Processor Communication",
      description: [
        "Shared Memory: CPUs communicate via shared data regions",
        "Message Passing: Explicit messages exchanged between CPUs",
        "Synchronization: Ensures consistency (using semaphores, barriers, locks)",
      ],
    },
    {
      topic: "Synchronization",
      description: [
        "Critical Sections: Ensuring only one process accesses shared resources",
        "Locks: Prevent simultaneous access",
        "Barriers: All processes must reach a point before proceeding",
      ],
    },
  ],
};

const notes: NoteType = {
  topic: "Microprocessor, Computer Organization and Architecture",
  chapters: [chapterOne, chapterTwo, chapterThree, chapterFour, chapterFive, chapterSix],
};

export default notes;
