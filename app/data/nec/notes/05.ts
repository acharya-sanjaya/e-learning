import {ChapterType, NoteType} from "./01";

const chapterOne: ChapterType = {
  topic: "Programming with 8085 and 8086 Microprocessors",
  contents: [
    {
      topic: "8085 Microprocessor",
      description: [
        "Data Bus: 8-bit",
        "Address Bus: 16-bit",
        "Operation Modes: Fetch, Decode, Execute",
        "Memory: 64KB addressable, includes RAM, ROM and I/O Ports",
        "Power: +5V",
        "Clock: ~3MHz",
        "",
        "Instructions (74):",
        "-> Data Transfer: MOV, MVI, IN, OUT",
        "-> Arithmetic: ADD, SUB, INR, DCR",
        "-> Logical: ANA, ORA, CMA, RLC",
        "-> Control: NOP, HLT, DI, EI",
        "-> Branching: JMP, CALL, RET, JZ, JNZ",
        "-> Instruction can be 1-byte, 2-byte, or 3-byte",
        "",
        "Instruction Format:",
        "-> 1-byte: Opcode(8)",
        "-> 2-byte: Opcode(8), Operand(8)",
        "-> 3-byte: Opcode(8), Operand_1(8), Operand_2(8)",
        "",
        "Data Format:",
        "-> Byte: 8-bit",
        "-> Word: 16-bit",
        "-> Supports BCD arithmetic",
        "-> Does not support strings and floating point",
        "",
        "Registers:",
        "-> Accumulator: A (Code: 111)",
        "-> General Purpose: B, C, D, E, H, L (Code: 000 - 101)",
        "-> Program Counter: PC",
        "-> Stack Pointer: SP",
        "",
        "Flag Registers (5):",
        "-> Zero(Z): Z=1 => Result is 0",
        "-> Sign(S): S=1 => Result is negative",
        "-> Parity(P): P=1 => Odd parity",
        "-> Auxiliary Carry(AC): Carry in BCD arithmetic",
        "-> Carry(C): Carry in binary arithmetic",
        "",
        "Hardware Interrupts (5):",
        "-> TRAP: Non-maskable, highest priority, critical situations (e.g., power failure)",
        "-> RST 7.5, RST 6.5, RST 5.5: Maskable interrupts with descending priority",
        "-> INTR: General-purpose interrupt, vectored through INTA signal",
        "-> Maskable Interrupts means these can be masked (disabled or ignored)",
        "",
        "Addressing Modes (5):",
        "-> Immediate",
        "-> Direct",
        "-> Indirect",
        "-> Register",
        "-> Implied / Implicit (no operand)",
      ],
    },
    {
      topic: "INTENDED_GAP",
      description: [],
    },
    {
      topic: "8086 Microprocessor",
      description: [
        "Data Bus: 16-bit",
        "Address Bus: 20-bit",
        "Operation Modes: Fetch, Decode, Execute (Supports pipelining)",
        "Instruction Pipelining: Overlapping execution phases (Fetching next instruction while executing current one)",
        "Memory: 1MB, includes RAM, ROM, and I/O Ports",
        "Power: +5V",
        "Clock: 5 to 10 MHz",
        "",
        "Instructions:",
        "-> Data Transfer: MOV, PUSH, POP",
        "-> Arithmetic: ADD, SUB, INC, DEC, MUL, DIV",
        "-> Logical: AND, OR, XOR, NOT, TEST",
        "-> Control: NOP, HLT, JMP, CALL, RET",
        "-> String: MOVSB, MOVSW, CMPSB, SCASB, REP",
        "-> Comparison: CMP, TEST, JZ, JNZ, JC, JNC",
        "-> Instruction sizes: 1-byte, 2-byte, or 3-byte",
        "",
        "Instruction Format:",
        "-> 1-byte: Opcode(8)",
        "-> 2-byte: Opcode(8), Operand(8)",
        "-> 3-byte: Opcode(8), Operand_1(8), Operand_2(8)",
        "-> For string operations, implicit mode is used",
        "",
        "Data Format:",
        "-> Byte: 8-bit",
        "-> Word: 16-bit",
        "-> Does not directly support BCD operations (but possible via software)",
        "-> Does not supports floating-point operations",
        "",
        "Registers:",
        "-> Accumulator: AX (Code: 000)",
        "-> Base Register: BX (Code: 011)",
        "-> Count Register: CX (Code: 010)",
        "-> Data Register: DX (Code: 100)",
        "-> Stack Pointer: SP",
        "-> Base Pointer: BP",
        "-> Source Index: SI",
        "-> Destination Index: DI",
        "-> Segment Registers: CS, DS, SS, ES",
        "-> Instruction Pointer: IP",
        "",
        "Pointers and Index Registers:",
        "-> SI: Source Index, used as source pointer for string operations",
        "-> DI: Destination Index, used as destination pointer for string operations",
        "-> BP: Base Pointer, points to base of stack segment",
        "-> SP: Stack Pointer, points to top of stack",
        "",
        "Flag Registers (size=16 bits, total flags=9):",
        "-> Carry (C)",
        "-> Parity (P)",
        "-> Auxiliary Carry (AC)",
        "-> Zero (Z)",
        "-> Sign (S)",
        "-> Trap (T): Enables single-step execution",
        "-> Interrupt Enable (I): I=1 => Enabled",
        "-> Direction (D): D=1 => String operations move in reverse",
        "-> Overflow (O): O=1 => Overflow in arithmetic operation",
        "",
        "Segmentation:",
        "-> CS: Code Segment",
        "-> DS: Data Segment",
        "-> SS: Stack Segment",
        "-> ES: Extra Segment",
        "",
        "Segment: Offset Addressing",
        "-> Physical address = Segment * 10H + Offset address",
        "-> Eg; Let CS= 2000H, IP = 0100H",
        "-> Then, Physical address = 2000H * 10H + 100H = 20100H",
        "",
        "Interrupts:",
        "-> Supports both h/w and s/w interrupts",
        "-> 256 interrupts (0-255): uses IVT",
        "",
        "Addressing Modes (usually 11 might differ according to book):",
        "-> Immediate",
        "-> Direct / Displacement",
        "-> Indirect",
        "-> Register",
        "-> Indexed",
        "-> Based Indexed",
        "-> Register Indirect",
        "-> Indexed Indirect",
        "-> Based Indexed Indirect",
        "-> String (Implied mode)",
        "-> I/O",
      ],
    },
    {
      topic: "INTENDED_GAP",
      description: [],
    },
    {
      topic: "Assembly Language Programming",
      description: [
        "Low-level, direct access to h/w components so, not easily portable",
        "",
        "Structure of an Assembly Program:",
        "-> Labels: identifier for memory address, helps in jumps and loops",
        "-> Mnemonics: represents instruction making it (more readable)",
        "-> Operands: like variables",
        "-> Directives: give instructions to the assembler",
        "-> Comments: for readability",
        "",
        "Debugging Assembly Programs:",
        "-> Stepping through instructions: execute one instruction at a time and check",
        "-> Use of breakpoints: they pause program execution at a specific line",
        "-> Inspect registers and memory: monitor values repeatedly to detect unexpected updates",
        "",
        "Optimizing Assembly Programs:",
        "-> Minimize instruction set",
        "-> Utilize registers",
        "-> Loop unrolling (expand loops before running to make normal flow instead of iteration)",
        "-> Instruction pipelining",
        "",
      ],
    },
    {
      topic: "COM",
      description: [
        "Executable file type",
        "Simple, single segment, fast, less portable",
        "Maximum 64KB",
        "Flat binary format, no header or metadata",
        "Always loads at 0100H (fixed)",
      ],
    },
    {
      topic: "EXE",
      description: [
        "Executable file type",
        "Can be more than 64KB",
        "Contains header or metadata",
        "Support multiple segments, modularity",
        "Loading address not fixed.",
      ],
    },
    {
      topic: "Assembling, Linking and Executing",
      description: [
        "Assembling: Converting assembly code to object code",
        "",
        "Linking: Combining (multiple files or libraries if any) object code into executable file includes resolving references",
        "",
        "Executing: Load, initialize, execute and terminate the linked executable file",
        "-> MASM and TASM are popular assemblers (for windows), LINK is a popular linker.",
      ],
    },
    {
      topic: "Single Pass Assemblers",
      description: [
        "Translating instructions + resolving symbols in single pass",
        "Single traversal (means reads source code from top to bottom ONCE)",
        "Faster but can't handle forward references",
      ],
    },
    {
      topic: "Two Pass Assemblers",
      description: [
        "Build the Symbol Table (SYMTAB) in first pass",
        "Generate object code in second pass",
        "Slower but handles forward references effectively",
      ],
    },
  ],
};

const chapterTwo: ChapterType = {
  topic: "Microprocessor System",
  contents: [
    {
      topic: "I/O and Memory Interfaces",
      description: [
        "Interface: Paths through which CPU communicates with devices",
        "Parallel Interface: Multiple bit lines for data transfer",
        "-> Multiple data at a time, high transfer rate BUT signal degradation, complex wiring, synchronization issues",
        "Serial Interface: Single bit line for data transfer",
        "-> simple wiring but comparatively slower, only one bit transfer at a time",
        "",
      ],
    },
    {
      topic: "Programmable Peripheral Interface (PPI)",
      description: [
        "allows CPU to communicate with peripheral devices",
        "includes bi-directional as well as uni-directional ports",
        "I/O ports:",
        "-> I/O ports: allow transfer",
        "-> Control ports: manage direction of transfer (in/out)",
        "",
        "Control Register:",
        "-> Configuration register: determine modes (input/output) of each ports",
        "-> Control bits: interrupts, clocking, data transfer protocols",
        "",
        "Status Register:",
        "-> Interrupt Status (if interrupt is pending)",
        "-> Data Status (if data is ready to read/write)",
        "",
        "Key Features:",
        "-> Mode (in/out) control for each ports individually",
        "-> Interrupt Capabilities",
        "-> Data Latching: (store data temporarily in a buffer)",
        "-> Bi-directional ports",
        "",
        "Modes:",
        "-> Mode 0: Basic (no handshaking or interrupts)",
        "-> Mode 1: Strobe signal (handshaking signal) and interrupt support",
        "-> Mode 2: Bi-directional",
      ],
    },
    {
      topic: "Serial Interface",
      description: [
        "Communication: Single data line transfers data bits",
        "Synchronous:",
        "-> Share a common clock signal",
        "-> faster, less flexible",
        "-> Eg; SPI, IIC, USB",
        "Asynchronous:",
        "-> Start/stop bits signal the beginning and end of data.",
        "-> slower, more flexible",
        "-> Eg; UART, RS-232 (Recommended), RS-485",
      ],
    },
    {
      topic: "Serial Interface Standards",
      description: [
        "UART: async, wires=2, 1mbps, bluetooth",
        "SPI: sync, wires=4, 10mbps, sensors and sd cards",
        "IIC: sync, wires=2, 400kbps, eeprom and rtc and sd cards",
        "USB: sync, wires=4-9, 40gbps, storage",
        "RS-232: async, wires=3, 115kbps, point-to-point, short distance",
        "RS-485: sync, wires=2, 10mbps, multi-point, long distance",
      ],
    },
    {
      topic: "Direct Memory Access (DMA)",
      description: [
        " Take control over system bus for direct data transfer between memory and peripherals.",
        "Modes of DMA:",
        "-> Burst Mode: Data is transferred in blocks without CPU interruption",
        "-> Cycle Stealing: DMA takes control of bus for short periods (interleaving with CPU).",
        "-> Transparent Mode: DMA takes control of bus only when CPU is not using it",
      ],
    },
  ],
};

const chapterThree: ChapterType = {
  topic: "Interrupt Operations",
  contents: [
    {
      topic: "Interrupts",
      description: [
        "Interrupt: Signal requesting CPU attention.",
        "-> Maskable: Can be ignored",
        "-> Non-Maskable: Cannot be ignored",
        "-> Hardware Interrupts: Asynchronous",
        "-> Software Interrupts: Synchronous",
        "-> Vector Interrupts: Fixed location for each interrupt (e.g., TRAP).",
        "-> Interrupt Priority: Determines which interrupt is handled first.",
        "",
        "Interrupt Service Routine (ISR):",
        "-> A function that executes when the respective interrupt occurs",
        "-> Fast, non-blocking, minimal resource usage",
        "-> Structure: Entry -> Process -> Exit",
      ],
    },
    {
      topic: "Interrupt Handling",
      description: [
        "8085: 5 interrupts (TRAP, RST 7.5, 6.5, 5.5, INTR).",
        "8086: More complex; uses Interrupt Vector Table (256 entries).",
        "INTR in 8085 vs. INT in 8086: Unified architecture in 8086 for managing up to 256 interrupts.",
      ],
    },
    {
      topic: "Parallelism",
      description: [
        "Real Parallelism: Multiple processors execute simultaneously.",
        "Pseudo-Parallelism: One processor switches rapidly between tasks (time slicing).",
        "Flynn's Classification: ",
        "-> SISD (Single Data Single Instruction)",
        "-> SIMD (Single Instruction Multiple Data)",
        "-> MIMD",
        "-> MISD",
      ],
    },
    {
      topic: "Resource Allocation and Deadlock",
      description: [
        "Resource Allocation: OS assigns resources to processes for execution.",
        "Deadlock: Circular waiting on resources among multiple processes.",
        "Causes of Deadlock:",
        "-> Mutual Exclusion",
        "-> Hold and Wait",
        "-> No Preemption",
        "-> Circular Wait",
        "",
        "Deadlock Handling: Prevention, Avoidance (e.g., Banker's Algorithm), or Detection & Recovery.",
        "Use Semaphores, Monitors to prevent deadlocks",
      ],
    },
    {
      topic: "Inter Process Communication",
      description: [
        "Shared Memory",
        "Message Passing: Processes send data blocks to message queues or pipes",
        "Signals: lightweight message to notify about events",
        "Sockets: send data across different machines over internet",
        "Pipes: send data between processes",
        "Remote Procedure Calls (RPC): one process invoke function on another process",
      ],
    },
  ],
};

const chapterFour: ChapterType = {
  topic: "Control and CPU Organization",
  contents: [
    {
      topic: "Control Memory",
      description: [
        "Stores microinstructions for CPU operations.",
        "Microinstructions: Specify control signals for execution steps.",
        "Sequencing Logic: Determines execution order in microprogrammed control.",
      ],
    },
    {
      topic: "Addressing Sequencing",
      description: [
        "Defines the flow of control through microinstructions.",
        "Methods: Sequential, Conditional branching, Subroutine calling.",
      ],
    },
    {
      topic: "Computer Configuration",
      description: [
        "Hardware components: CPU, memory, I/O.",
        "Bus System: Interconnects components for communication.",
        "System Configuration: Balancing speed, cost, and power.",
      ],
    },
    {
      topic: "Microinstruction Format",
      description: [
        "Control Word: Specifies control signals for hardware units.",
        "Components: Address field, Opcode (operation code), and Control bits.",
        "Types: Horizontal (parallel signals) and Vertical (encoded signals).",
      ],
    },
    {
      topic: "Design of Control Unit",
      description: [
        "Hardwired Control: Logic circuits execute fixed control signals.",
        "Microprogrammed Control: Uses microinstructions for flexible control.",
        "Key Tasks: Generating clock, decoding instructions, managing data flow.",
      ],
    },
    {
      topic: "CPU Structure and Function",
      description: [
        "Core Units: ALU (operations), Registers (storage), Control Unit (coordination).",
        "Fetch-Decode-Execute Cycle: Steps of program execution.",
        "Registers: PC (next instruction), MAR/MDR (memory access), ACC (result).",
      ],
    },
    {
      topic: "Arithmetic and Logic Unit (ALU)",
      description: [
        "Performs: Addition, subtraction, AND, OR, NOT, shifts.",
        "Condition Flags: Z (Zero), S (Sign), P (Parity), C (Carry).",
      ],
    },
    {
      topic: "Instruction Formats",
      description: [
        "Defines layout of instructions.",
        "Components: Opcode, Addressing Mode, Operand(s).",
        "Varies with length: Fixed, Variable, Hybrid formats.",
      ],
    },
    {
      topic: "Addressing Modes",
      description: [
        "Ways to access operands in instructions.",
        "Immediate, Register, Direct, Indirect, Indexed, Based.",
      ],
    },
    {
      topic: "Data Transfer and Manipulation",
      description: [
        "Transfer: Between CPU, memory, and I/O (e.g., MOV, LOAD, STORE).",
        "Manipulation: Arithmetic/Logic on data (e.g., ADD, XOR).",
      ],
    },
    {
      topic: "RISC vs CISC",
      description: [
        "RISC: Simplified instructions, single-cycle execution, load/store design.",
        "CISC: Complex instructions, multi-cycle execution, hardware-intensive.",
        "Comparison: RISC is faster per instruction; CISC packs more power in fewer instructions.",
      ],
    },
    {
      topic: "Pipelining and Parallel Processing",
      description: [
        "Pipelining: Overlaps instruction execution; stages include Fetch, Decode, Execute, Memory, Writeback.",
        "Parallel Processing: Multiple instructions executed concurrently using multiple ALUs or CPUs.",
        "Superscalar: Multiple pipelines in a single CPU.",
      ],
    },
  ],
};

const chapterFive: ChapterType = {
  topic: "Computer arithmetic and memory system",
  contents: [
    {
      topic: "Arithmetic and Logical Operations",
      description: ["Floating Point Ops: Handles fractions using IEEE 754 standard."],
    },
    {
      topic: "Memory Hierarchy",
      description: [
        "Registers: Fastest, smallest, in CPU.",
        "Cache: Small, close to CPU; temporary storage for frequent/recent data.",
        "RAM: Larger than cache, slower, for active processes.",
        "Secondary (HDD/SSD): Non-volatile; stores data permanently.",
        "Tertiary (Disks/Tapes): For backups; slowest.",
      ],
    },
    {
      topic: "Cache Memory Principles",
      description: [
        "Speeds up data access for frequently/recently used data.",
        "Faster than RAM but smaller.",
        "Locality of Reference: Temporal (re-use) and Spatial (adjacent memory).",
      ],
    },
    {
      topic: "Elements of Cache Design",
      description: [
        "Cache Size: Bigger caches = more data but higher latency.",
        "Mapping Function: Determines how data maps to cache lines.",
        "Direct Mapping: Each memory block maps to 1 specific cache line.",
        "Replacement Algorithms: Strategies to evict old cache entries (e.g., LRU, FIFO).",
        "Write Policy: How writes to memory are handled (write-through/write-back).",
      ],
    },
  ],
};

const chapterSix: ChapterType = {
  topic: "Input-Output organization and multiprocessor",
  contents: [
    {
      topic: "Peripheral Devices and I/O Modules",
      description: [
        "Peripheral Devices: Input (keyboard, mouse), Output (monitor, printer), Storage (disks).",
        "I/O Modules: Interface between peripherals and CPU/memory.",
        "Functions: Control, Addressing, Data transfer, Synchronization.",
      ],
    },
    {
      topic: "Input-Output Interface",
      description: [
        "Programmed I/O: CPU handles all data transfers.",
        "Interrupt-driven I/O: Peripherals interrupt CPU when ready for data.",
        "Direct Memory Access (DMA): Data transferred between memory and device without CPU intervention.",
      ],
    },
    {
      topic: "Modes of Data Transfer",
      description: [
        "Synchronous: Data transfer at fixed intervals; requires clock signal.",
        "Asynchronous: Data transfer without a clock; uses handshaking signals.",
        "DMA: Direct memory access, bypassing CPU for large data transfers.",
      ],
    },
    {
      topic: "Characteristics of Multiprocessors",
      description: [
        "Multiple CPUs: Enhances performance and reliability.",
        "Shared Memory: CPUs share a global memory.",
        "Types: Symmetric (SMP) and Asymmetric (AMP) multiprocessing.",
      ],
    },
    {
      topic: "Interconnection Structures",
      description: [
        "Bus-based: CPUs and memory communicate via a shared bus.",
        "Crossbar: Each CPU connects to every memory module.",
        "Mesh/Hypercube: CPUs connected in multi-dimensional arrays.",
      ],
    },
    {
      topic: "Inter-Processor Communication",
      description: [
        "Shared Memory: CPUs communicate via shared data regions.",
        "Message Passing: Explicit messages exchanged between CPUs.",
        "Synchronization: Ensures consistency (using semaphores, barriers, locks).",
      ],
    },
    {
      topic: "Synchronization",
      description: [
        "Critical Sections: Ensuring only one process accesses shared resources.",
        "Locks: Prevent simultaneous access.",
        "Barriers: All processes must reach a point before proceeding.",
      ],
    },
  ],
};

const notes: NoteType = {
  topic: "Microprocessor, Computer Organization and Architecture",
  chapters: [chapterOne, chapterTwo, chapterThree, chapterFour, chapterFive, chapterSix],
};

export default notes;
